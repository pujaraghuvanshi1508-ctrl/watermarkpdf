<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDF Watermark Editor</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tailwindcss/2.2.19/tailwind.min.css">
    <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://unpkg.com/pdf-lib@1.17.1/dist/pdf-lib.js"></script>
    <!-- Use the non-module version of PDF.js to avoid "Dynamic require" errors -->
    <script src="https://unpkg.com/pdfjs-dist@2.16.105/build/pdf.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
        }
        .page-container {
            position: relative;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            overflow: hidden;
            background-color: white;
            border-radius: 0.75rem;
        }
        .page-container canvas {
            display: block;
        }
    </style>
</head>
<body class="bg-gray-100 font-sans leading-normal tracking-normal text-gray-900">
    <div id="root"></div>

    <script type="text/babel">
        // Set the workerSrc directly to the non-module worker file
        if (typeof pdfjsLib !== 'undefined') {
          pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://unpkg.com/pdfjs-dist@2.16.105/build/pdf.worker.js';
        }

        const { useState, useRef, useEffect } = React;
        const { PDFDocument, StandardFonts, rgb, degrees } = PDFLib;

        const App = () => {
            const [file, setFile] = useState(null);
            const [loading, setLoading] = useState(false);
            const [downloadUrl, setDownloadUrl] = useState('');
            const [error, setError] = useState('');
            const [currentPage, setCurrentPage] = useState(1);
            const [pdfDoc, setPdfDoc] = useState(null);
            const canvasRef = useRef(null);
            const renderTaskRef = useRef(null); // Reference to the ongoing render task

            // Watermark state
            const [watermarkType, setWatermarkType] = useState('text');
            const [watermarkText, setWatermarkText] = useState('Confidential');
            const [watermarkImageFile, setWatermarkImageFile] = useState(null);
            const [tiltAngle, setTiltAngle] = useState(-30);
            const [opacity, setOpacity] = useState(0.3);
            const [fontSize, setFontSize] = useState(40);
            const [fontFamily, setFontFamily] = useState('Helvetica');
            const [color, setColor] = useState('#000000');
            const [position, setPosition] = useState('center');
            const [repeat, setRepeat] = useState('single');
            const [isStroke, setIsStroke] = useState(false);
            const [blendMode, setBlendMode] = useState('Normal');
            const [imagePreviewUrl, setImagePreviewUrl] = useState(null);
            const [imageWatermarkLayer, setImageWatermarkLayer] = useState('above');
            
            const handleFileChange = (e) => {
                const selectedFile = e.target.files[0];
                if (selectedFile && selectedFile.type === 'application/pdf') {
                    if (selectedFile.size > 100 * 1024 * 1024) {
                        setError('File size exceeds 100MB limit.');
                        return;
                    }
                    setFile(selectedFile);
                    setDownloadUrl('');
                    loadPDF(selectedFile);
                } else {
                    setFile(null);
                    setError('Please upload a valid PDF file.');
                }
            };
            
            const handleImageChange = (e) => {
                const selectedFile = e.target.files[0];
                setWatermarkImageFile(selectedFile);
                if (selectedFile) {
                    const reader = new FileReader();
                    reader.onloadend = () => {
                        setImagePreviewUrl(reader.result);
                    };
                    reader.readAsDataURL(selectedFile);
                } else {
                    setImagePreviewUrl(null);
                }
            };

            const handleFontSizeChange = (amount) => {
                setFontSize(prevSize => Math.max(10, Math.min(100, prevSize + amount)));
            };

            const handleImageSizeChange = (amount) => {
                const newSize = fontSize + amount;
                setFontSize(Math.max(10, Math.min(200, newSize)));
            };

            const loadPDF = async (pdfFile) => {
                const fileReader = new FileReader();
                fileReader.onload = async (e) => {
                    const typedArray = new Uint8Array(e.target.result);
                    const pdf = await pdfjsLib.getDocument({ data: typedArray }).promise;
                    setPdfDoc(pdf);
                    setCurrentPage(1);
                };
                fileReader.readAsArrayBuffer(pdfFile);
            };

            const renderPage = async (pageNumber) => {
                if (!pdfDoc || !canvasRef.current) return;
                
                // Cancel any ongoing render task before starting a new one
                if (renderTaskRef.current) {
                    renderTaskRef.current.cancel();
                }

                const page = await pdfDoc.getPage(pageNumber);
                const viewport = page.getViewport({ scale: 1.5 });
                const canvas = canvasRef.current;
                const context = canvas.getContext('2d');
                canvas.height = viewport.height;
                canvas.width = viewport.width;
                const renderContext = { canvasContext: context, viewport: viewport };
                
                const renderTask = page.render(renderContext);
                renderTaskRef.current = renderTask;

                try {
                    await renderTask.promise;
                } catch (err) {
                    if (err.name === 'RenderingCancelledException') {
                        // This is expected behavior when a new render task is initiated.
                        console.log('Rendering cancelled, proceeding with new render.');
                    } else {
                        throw err;
                    }
                }
                
                renderTaskRef.current = null; // Clear the ref after completion
            };

            const renderWatermark = async () => {
                if (!canvasRef.current || (!watermarkText && !imagePreviewUrl)) return;
                
                const canvas = canvasRef.current;
                const ctx = canvas.getContext('2d');
                const { width, height } = canvas;
                const angleRad = tiltAngle * Math.PI / 180;

                ctx.globalAlpha = opacity;
                const drawSingleWatermark = (item, x, y, itemWidth, itemHeight) => {
                    ctx.save();
                    ctx.translate(x, y);
                    ctx.rotate(angleRad);
                    if (watermarkType === 'text') {
                        if (isStroke) {
                            ctx.strokeStyle = color;
                            ctx.strokeText(item, 0, 0);
                        } else {
                            ctx.fillStyle = color;
                            ctx.fillText(item, 0, 0);
                        }
                    } else if (watermarkType === 'image') {
                        ctx.drawImage(item, -itemWidth/2, -itemHeight/2, itemWidth, itemHeight);
                    }
                    ctx.restore();
                };

                const renderItem = async () => {
                    if (watermarkType === 'text' && watermarkText) {
                        ctx.font = `${fontSize}px Helvetica`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        const textWidth = ctx.measureText(watermarkText).width;
                        const textHeight = parseInt(ctx.font);

                        if (repeat === 'single') {
                            let x, y;
                            switch (position) {
                                case 'center': x = width / 2; y = height / 2; break;
                                case 'top-left': x = textWidth / 2 + 20; y = textHeight / 2 + 20; break;
                                case 'top-right': x = width - textWidth / 2 - 20; y = textHeight / 2 + 20; break;
                                case 'bottom-left': x = textWidth / 2 + 20; y = height - textHeight / 2 - 20; break;
                                case 'bottom-right': x = width - textWidth / 2 - 20; y = height - textHeight / 2 - 20; break;
                            }
                            drawSingleWatermark(watermarkText, x, y, textWidth, textHeight);
                        }
                    } else if (watermarkType === 'image' && imagePreviewUrl) {
                        const img = new Image();
                        img.onload = () => {
                            const scale = fontSize / 100;
                            const imgWidth = img.width * scale;
                            const imgHeight = img.height * scale;
                            
                            if (repeat === 'single') {
                                let x, y;
                                switch (position) {
                                    case 'center': x = width / 2; y = height / 2; break;
                                    case 'top-left': x = imgWidth/2 + 20; y = imgHeight/2 + 20; break;
                                    case 'top-right': x = width - imgWidth/2 - 20; y = imgHeight/2 + 20; break;
                                    case 'bottom-left': x = imgWidth/2 + 20; y = height - imgHeight/2 - 20; break;
                                    case 'bottom-right': x = width - imgWidth/2 - 20; y = height - imgHeight/2 - 20; break;
                                }
                                drawSingleWatermark(img, x, y, imgWidth, imgHeight);
                            }
                        };
                        img.src = imagePreviewUrl;
                    }
                };

                renderItem();
            };

            const processPDF = async () => {
                if (!file) {
                    setError('Please select a PDF file to upload.');
                    return;
                }
                setLoading(true);
                setDownloadUrl('');
                setError('');

                try {
                    const pdfBytes = new Uint8Array(await file.arrayBuffer());
                    const pdfDoc = await PDFDocument.load(pdfBytes);

                    const pages = pdfDoc.getPages();
                    
                    const drawTextWatermark = async (page) => {
                         const font = await pdfDoc.embedFont(StandardFonts.Helvetica);
                         const watermarkColor = rgb(parseInt(color.slice(1, 3), 16) / 255, parseInt(color.slice(3, 5), 16) / 255, parseInt(color.slice(5, 7), 16) / 255);
                         const { width, height } = page.getSize();
                         const textWidth = font.widthOfTextAtSize(watermarkText, fontSize);
                         const textHeight = font.heightAtSize(fontSize);
                         const drawWatermark = (x, y) => {
                             page.drawText(watermarkText, { x, y, size: fontSize, font, color: watermarkColor, opacity: parseFloat(opacity), rotate: degrees(parseInt(tiltAngle)) });
                         };
                         if (repeat === 'single') {
                             let x, y;
                             switch (position) {
                                 case 'center': x = (width - textWidth) / 2; y = (height - textHeight) / 2; break;
                                 case 'top-left': x = 20; y = height - textHeight - 20; break;
                                 case 'top-right': x = width - textWidth - 20; y = height - textHeight - 20; break;
                                 case 'bottom-left': x = 20; y = 20; break;
                                 case 'bottom-right': x = width - textWidth - 20; y = 20; break;
                             }
                             drawWatermark(x, y);
                         } else if (repeat === 'tile') {
                             const tileWidth = textWidth + 100;
                             const tileHeight = textHeight + 100;
                             for (let y = 0; y < height; y += tileHeight) {
                                 for (let x = 0; x < width; x += tileWidth) {
                                     drawWatermark(x, y);
                                 }
                             }
                         } else if (repeat === 'diagonal-tile') {
                             const diagonalAngleRad = -45 * Math.PI / 180;
                             const step = Math.sqrt(Math.pow(width, 2) + Math.pow(height, 2)) / 5;
                             for (let i = 0; i < 10; i++) {
                                 const x = (i - 5) * step * Math.cos(diagonalAngleRad);
                                 const y = (i - 5) * step * Math.sin(diagonalAngleRad);
                                 drawWatermark(x + width / 2, y + height / 2);
                             }
                         }
                     };
                    
                    const embedImageWatermark = async (page) => {
                        const imageBytes = new Uint8Array(await watermarkImageFile.arrayBuffer());
                        let image;
                        if (watermarkImageFile.type === 'image/jpeg') {
                            image = await pdfDoc.embedJpg(imageBytes);
                        } else if (watermarkImageFile.type === 'image/png') {
                            image = await pdfDoc.embedPng(imageBytes);
                        } else {
                            throw new Error('Unsupported image type for PDF embedding. Please use JPEG or PNG.');
                        }
                        const { width, height } = page.getSize();
                        const scale = fontSize / 100;
                        const imgWidth = image.width * scale;
                        const imgHeight = image.height * scale;
                        const drawWatermark = (x, y) => {
                            page.drawImage(image, { x, y, width: imgWidth, height: imgHeight, opacity: parseFloat(opacity), rotate: degrees(parseInt(tiltAngle)) });
                        };
                        if (repeat === 'single') {
                            let x, y;
                            switch (position) {
                                case 'center': x = (width - imgWidth) / 2; y = (height - imgHeight) / 2; break;
                                case 'top-left': x = 20; y = height - imgHeight - 20; break;
                                case 'top-right': x = width - imgWidth - 20; y = height - imgHeight - 20; break;
                                case 'bottom-left': x = 20; y = 20; break;
                                case 'bottom-right': x = width - imgWidth - 20; y = 20; break;
                            }
                            drawWatermark(x, y);
                        }
                    };

                    if (watermarkType === 'text' && watermarkText) {
                        for (const page of pages) await drawTextWatermark(page);
                    } else if (watermarkType === 'image' && watermarkImageFile) {
                        for (const page of pages) await embedImageWatermark(page);
                    }

                    const modifiedPdfBytes = await pdfDoc.save();
                    const blob = new Blob([modifiedPdfBytes], { type: 'application/pdf' });
                    const url = URL.createObjectURL(blob);
                    setDownloadUrl(url);

                } catch (err) {
                    console.error('Processing failed:', err);
                    setError('Processing failed: ' + err.message);
                } finally {
                    setLoading(false);
                }
            };

            useEffect(() => {
                if (pdfDoc) {
                    renderPage(currentPage).then(() => {
                        renderWatermark();
                    });
                }
                
                return () => {
                    // Cleanup function to cancel any ongoing render task
                    if (renderTaskRef.current) {
                        renderTaskRef.current.cancel();
                        renderTaskRef.current = null;
                    }
                };
            }, [pdfDoc, currentPage, watermarkText, watermarkType, tiltAngle, opacity, fontSize, fontFamily, color, position, repeat, isStroke, blendMode, imageWatermarkLayer, imagePreviewUrl]);
            
            return (
                <div className="min-h-screen bg-gray-100 font-sans leading-normal tracking-normal text-gray-900">
                    <div className="flex flex-col lg:flex-row items-center justify-center p-4">
                        <div className="bg-white p-8 rounded-2xl shadow-xl w-full max-w-6xl space-y-8 lg:space-y-0 lg:flex lg:gap-8 border-2 border-gray-200">
                            <div className="w-full lg:w-1/2 space-y-6">
                                <h1 className="text-4xl font-extrabold text-center text-blue-600">PDF Watermark Editor</h1>
                                <p className="text-center text-gray-600">Add text or image watermarks to your PDF.</p>
                                <div className="space-y-4">
                                    <div>
                                        <label htmlFor="pdfFile" className="block text-sm font-medium text-gray-700">
                                            Upload PDF File (Max 100MB)
                                        </label>
                                        <input id="pdfFile" type="file" accept=".pdf" onChange={handleFileChange}
                                            className="mt-1 block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-blue-50 file:text-blue-700 hover:file:bg-blue-100" />
                                        {error && <p className="mt-2 text-sm text-red-500">{error}</p>}
                                    </div>
                                    {pdfDoc && (
                                        <div className="space-y-4">
                                            <hr className="border-gray-300" />
                                            <h2 className="text-xl font-bold text-gray-800">Watermark Options</h2>
                                            <div className="p-4 border rounded-lg space-y-4 bg-gray-50 border-gray-200">
                                                <h3 className="font-semibold text-gray-800">Watermark Settings</h3>
                                                <div>
                                                    <label className="block text-sm font-medium text-gray-700">Watermark Type</label>
                                                    <select value={watermarkType} onChange={(e) => setWatermarkType(e.target.value)}
                                                        className="mt-1 block w-full rounded-md border-gray-300 shadow-sm bg-white text-gray-900">
                                                        <option value="text">Text</option>
                                                        <option value="image">Image</option>
                                                    </select>
                                                </div>
                                                {watermarkType === 'text' && (
                                                    <>
                                                        <input type="text" placeholder="Watermark Text" value={watermarkText} onChange={(e) => setWatermarkText(e.target.value)}
                                                            className="block w-full rounded-md border-gray-300 shadow-sm bg-white text-gray-900" />
                                                        <div className="space-y-2">
                                                            <label htmlFor="fontSize" className="block text-sm font-medium text-gray-700">Font Size ({fontSize})</label>
                                                            <div className="flex space-x-2">
                                                                <button onClick={() => handleFontSizeChange(-5)}
                                                                        className="px-3 py-1 bg-gray-200 rounded-md hover:bg-gray-300">-</button>
                                                                <input type="range" min="10" max="100" value={fontSize} onChange={(e) => setFontSize(parseInt(e.target.value))}
                                                                    className="w-full accent-blue-600" />
                                                                <button onClick={() => handleFontSizeChange(5)}
                                                                        className="px-3 py-1 bg-gray-200 rounded-md hover:bg-gray-300">+</button>
                                                            </div>
                                                        </div>
                                                    </>
                                                )}
                                                {watermarkType === 'image' && (
                                                    <>
                                                        <input type="file" accept="image/*" onChange={handleImageChange}
                                                            className="block w-full text-sm text-gray-500" />
                                                        <div className="space-y-2">
                                                            <label htmlFor="imageSize" className="block text-sm font-medium text-gray-700">Image Size ({fontSize}%)</label>
                                                            <div className="flex space-x-2">
                                                                <button onClick={() => handleImageSizeChange(-10)}
                                                                        className="px-3 py-1 bg-gray-200 rounded-md hover:bg-gray-300">-</button>
                                                                <input type="range" min="10" max="200" value={fontSize} onChange={(e) => setFontSize(parseInt(e.target.value))}
                                                                    className="w-full accent-blue-600" />
                                                                <button onClick={() => handleImageSizeChange(10)}
                                                                        className="px-3 py-1 bg-gray-200 rounded-md hover:bg-gray-300">+</button>
                                                            </div>
                                                        </div>
                                                    </>
                                                )}
                                                <div>
                                                    <label className="block text-sm font-medium text-gray-700">Tilt Angle ({tiltAngle}°)</label>
                                                    <input type="range" min="-90" max="90" value={tiltAngle} onChange={(e) => setTiltAngle(e.target.value)} className="w-full" />
                                                </div>
                                                <div>
                                                    <label className="block text-sm font-medium text-gray-700">Opacity ({Math.round(opacity * 100)}%)</label>
                                                    <input type="range" min="0" max="1" step="0.01" value={opacity} onChange={(e) => setOpacity(e.target.value)} className="w-full" />
                                                </div>
                                                <div>
                                                    <label className="block text-sm font-medium text-gray-700">Position</label>
                                                    <select value={position} onChange={(e) => setPosition(e.target.value)}
                                                        className="mt-1 block w-full rounded-md border-gray-300 shadow-sm bg-white text-gray-900">
                                                        <option value="center">Center</option>
                                                        <option value="top-left">Top-Left</option>
                                                        <option value="top-right">Top-Right</option>
                                                        <option value="bottom-left">Bottom-Left</option>
                                                        <option value="bottom-right">Bottom-Right</option>
                                                    </select>
                                                </div>
                                                <div>
                                                    <label className="block text-sm font-medium text-gray-700">Repeat</label>
                                                    <select value={repeat} onChange={(e) => setRepeat(e.target.value)}
                                                        className="mt-1 block w-full rounded-md border-gray-300 shadow-sm bg-white text-gray-900">
                                                        <option value="single">Single</option>
                                                        <option value="tile">Tile</option>
                                                        <option value="diagonal-tile">Diagonal Tile</option>
                                                    </select>
                                                </div>
                                                {watermarkType === 'image' && (
                                                    <div className="flex items-center space-x-2">
                                                        <button onClick={() => setImageWatermarkLayer(imageWatermarkLayer === 'above' ? 'below' : 'above')}
                                                                className="px-4 py-2 bg-gray-200 rounded-md text-gray-800 hover:bg-gray-300">
                                                            Place {imageWatermarkLayer === 'above' ? 'Below' : 'Above'} PDF
                                                        </button>
                                                    </div>
                                                )}
                                            </div>
                                            <button onClick={processPDF} disabled={!file || loading}
                                                className="w-full py-3 px-4 rounded-md font-semibold text-white transition-colors duration-200 bg-blue-600 hover:bg-blue-700 disabled:bg-blue-400">
                                                {loading ? 'Processing...' : 'Process & Download PDF'}
                                            </button>
                                            {downloadUrl && (
                                                <div className="mt-6 text-center">
                                                    <a href={downloadUrl} download="edited_document.pdf"
                                                        className="inline-flex items-center px-6 py-3 border border-transparent text-base font-medium rounded-full shadow-sm text-white bg-green-600 hover:bg-green-700">
                                                        Download Edited PDF
                                                    </a>
                                                </div>
                                            )}
                                        </div>
                                    )}
                                </div>
                            </div>
                            <div className="w-full lg:w-1/2 p-4 bg-gray-200 rounded-2xl flex flex-col items-center justify-center border-2 border-gray-300">
                                {pdfDoc ? (
                                    <>
                                        <div className="flex justify-between w-full mb-2">
                                            <button onClick={() => setCurrentPage(prev => Math.max(1, prev - 1))} disabled={currentPage <= 1}
                                                className="px-3 py-1 bg-gray-300 text-gray-800 rounded-md hover:bg-gray-400">Previous</button>
                                            <span className="text-gray-600">Page {currentPage} of {pdfDoc.numPages}</span>
                                            <button onClick={() => setCurrentPage(prev => Math.min(pdfDoc.numPages, prev + 1))} disabled={currentPage >= pdfDoc.numPages}
                                                className="px-3 py-1 bg-gray-300 text-gray-800 rounded-md hover:bg-gray-400">Next</button>
                                        </div>
                                        <div className="page-container">
                                            <canvas ref={canvasRef}></canvas>
                                        </div>
                                    </>
                                ) : (
                                    <div className="text-center text-gray-500">
                                        <svg className="w-20 h-20 mx-auto mb-4" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                                            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M4 16l4.586-4.586a2 2 0 012.828 0L15 14m-3 6l-4.586-4.586a2 2 0 01-2.828 0L7 10m-4 6l4.586-4.586a2 2 0 012.828 0L15 14l-4.586-4.586a2 2 0 00-2.828 0L7 10"></path>
                                        </svg>
                                        <p>Upload a PDF to get started</p>
                                    </div>
                                )}
                            </div>
                        </div>
                    </div>
                </div>
            );
        };
        const rootElement = document.getElementById('root');
        const root = ReactDOM.createRoot(rootElement);
        root.render(<App />);
    </script>
</body>
</html>
